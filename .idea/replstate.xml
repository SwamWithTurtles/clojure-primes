<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1397479752141">{:repl-history {:ide [], :local [&quot;(defn powerMod \&quot;modular exponentiation\&quot; [b e m]\n  (defn m* [p q] (mod (* p q) m))\n  (loop [b b, e e, x 1]\n    (if (zero? e) x\n                  (if (even? e) (recur (m* b b) (/ e 2) x)\n                                (recur (m* b b) (quot e 2) (m* b x))))))&quot; &quot;(powerMod 1 1 1)&quot; &quot;(powerMod 2 1 3)&quot; &quot;(powerMod 4 1 3)&quot; &quot;(defn is-prime? [n]\n  (loop [num n recursLeft 10]\n    (if (zero? recursLeft)\n      true\n      (if (= 1 (powerMod (+ 1 (rand-int (- n 2)) n (- n 1)))) false\n                                                              (recur n (- recursLeft 1))))))&quot; &quot;is-prime? 2&quot; &quot;(defn is-prime? [n]\n  (loop [num n recursLeft 10]\n    (if (zero? recursLeft)\n      true\n      (if (= 1 (powerMod (rand-int (- n 2)) n (- n 1))) false\n                                                        (recur n (- recursLeft 1))))))&quot; &quot;(is-prime? 2)&quot; &quot;(is-prime? 3)&quot; &quot;(is-prime? 4)&quot; &quot;(is-prime? 100)&quot; &quot;(is-prime? 10000)&quot; &quot;(is-prime? 1443)&quot; &quot;(require 'clojure.contrib.math)\n\n(defn rdmOfMagnitude [order-of-magnitude]\n  (rand-int (expt 10 order-of-magnitude))\n  )\n&quot; &quot;(ns clojure_primes.stats-runner\n  (require ['clojure_primes.deterministic :as det]\n           ['clojure_primes.nondeterministic :as non-det]\n           ['clojure.math.numeric-tower :as math])\n\n  (defn rdmOfMagnitude [order-of-magnitude]\n    (rand-int (expt 10 order-of-magnitude))\n    )\n\n  (defn algorithms-agree [n recur-attempts]\n    (= (det.is-prime? n) (non-det.is-prime? n recur-attempts)))\n\n  (defn run-statistics [order-of-magnitude recur-attempts sample-size]\n    (loop [num-correct 0 total-num 0 samples (take sample-size (repeatedly #(rdmOfMagnitude order-of-magnitude)))]\n      (if empty? samples [num-correct total-num]\n                 (recur (+ num-correct (if (algorithms-agree (head sample) 1 0)))\n                        (+ total-num 1)\n                        (tail sample)))))\n\n  )&quot; &quot;(defn rdmOfMagnitude [order-of-magnitude]\n  (rand-int (expt 10 order-of-magnitude))\n  )&quot; &quot;(defn algorithms-agree [n recur-attempts]\n  (= (det.is-prime? n) (non-det.is-prime? n recur-attempts)))&quot; &quot;(defn is-prime? [n noAttempts]\n  (loop [num n recursLeft noAttempts]\n    (if (zero? recursLeft)\n      true\n      (if (= 1 (powerMod (rand-int (- n 2)) n (- n 1))) false\n                                                        (recur n (- recursLeft 1))))))&quot; &quot;(ns clojure_primes.deterministic\n  (defn is-prime? [n]\n    (zero? (count (filter #(zero? (rem n %)) (range 3 n 2))))\n    )\n  )\n\n&quot; &quot;(defn is-prime? [n]\n  (zero? (count (filter #(zero? (rem n %)) (range 3 n 2)))))&quot; &quot;(+2 2)&quot; &quot;(+ 2 2)&quot; &quot;(defn a [b] (+ b 1))&quot; &quot;(a 3)&quot; &quot;(defn r [x] (rand-int (expt 10 x)))&quot; &quot;(require ['clojure_primes.deterministic :as det]\n         ['clojure_primes.nondeterministic :as non-det]\n         ['clojure.math.numeric-tower :as math])&quot; &quot;(require ['clojure.math.numeric-tower :as math])&quot; &quot;(:require ['clojure.math.numeric-tower :as math])&quot; &quot;(require '[clojure_primes.deterministic :as det]\n         '[clojure_primes.nondeterministic :as non-det]\n         '[clojure.math.numeric-tower :as math])&quot; &quot;(ns clojure_primes.deterministic\n  (defn is-prime? [n]\n    (zero? (count (filter #(zero? (rem n %)) (range 3 n 2))))))&quot; &quot;(defn rdmOfMagnitude [order-of-magnitude]\n  (rand-int (expt 10 order-of-magnitude))\n  )\n&quot; &quot;(defn a [b] (+ b 1))\n&quot; &quot;(defn a [x] (+ x 1))&quot; &quot;(a 1)&quot; &quot;(r 10)&quot; &quot;(defn r [x] (rand-int x))&quot; &quot;(expt 1 1)&quot; &quot;(require '[clojure.math.numeric-tower :as math])&quot; &quot;(ns clojure_primes.stats-runner)\n\n(defn det-prime? [n]\n  (zero? (count (filter #(zero? (rem n %)) (range 3 n 2)))))\n\n(defn powerMod [b e m]\n  (defn m* [p q] (mod (* p q) m))\n  (loop [b b, e e, x 1]\n    (if (zero? e) x\n                  (if (even? e) (recur (m* b b) (/ e 2) x)\n                                (recur (m* b b) (quot e 2) (m* b x))))))\n\n(defn nondet-prime? [n noAttempts]\n  (loop [num n recursLeft noAttempts]\n    (if (zero? recursLeft) true ;Probably not prime\n                           (if (= 1 (powerMod (rand-int (- n 2)) n (- n 1))) false ;Composite\n                                                                             (recur n (- recursLeft 1))))))\n\n(defn rdmOfMagnitude [order-of-magnitude]\n  (rand-int (powerMod 10 order-of-magnitude 1)))\n\n(defn algorithms-agree [n recur-attempts]\n  (= (det-prime? n) (nondet-prime? n recur-attempts)))\n\n(defn run-statistics [order-of-magnitude recur-attempts sample-size]\n  (loop [num-correct 0 total-num 0 samples (take sample-size (repeatedly #(rdmOfMagnitude order-of-magnitude)))]\n    (if empty? samples [num-correct total-num]\n               (recur (+ num-correct (if (algorithms-agree (first samples) 1 0)))\n                      (+ total-num 1)\n                      (rest samples)))))&quot; &quot;(ns clojure_primes.stats-runner)\n\n(defn det-prime? [n]\n  (zero? (count (filter #(zero? (rem n %)) (range 3 n 2)))))\n\n(defn powerMod [b e m]\n  (defn m* [p q] (mod (* p q) m))\n  (loop [b b, e e, x 1]\n    (if (zero? e) x\n                  (if (even? e) (recur (m* b b) (/ e 2) x)\n                                (recur (m* b b) (quot e 2) (m* b x))))))\n\n(defn nondet-prime? [n noAttempts]\n  (loop [num n recursLeft noAttempts]\n    (if (zero? recursLeft) true ;Probably not prime\n                           (if (= 1 (powerMod (rand-int (- n 2)) n (- n 1))) false ;Composite\n                                                                             (recur n (- recursLeft 1))))))\n\n(defn rdmOfMagnitude [order-of-magnitude]\n  (rand-int (powerMod 10 order-of-magnitude 1)))\n\n(defn algorithms-agree [n recur-attempts]\n  (= (det-prime? n) (nondet-prime? n recur-attempts)))\n\n(defn run-statistics [order-of-magnitude recur-attempts sample-size]\n  (loop [num-correct 0 total-num 0 samples (take sample-size (repeatedly #(rdmOfMagnitude order-of-magnitude)))]\n    (if (empty? samples) [num-correct total-num]\n                         (recur (+ num-correct (if (algorithms-agree (first samples) 1 0)))\n                                (+ total-num 1)\n                                (rest samples)))))&quot; &quot;(ns clojure_primes.stats-runner)\n\n(defn det-prime? [n]\n  (zero? (count (filter #(zero? (rem n %)) (range 3 n 2)))))\n\n(defn powerMod [b e m]\n  (defn m* [p q] (mod (* p q) m))\n  (loop [b b, e e, x 1]\n    (if (zero? e) x\n                  (if (even? e) (recur (m* b b) (/ e 2) x)\n                                (recur (m* b b) (quot e 2) (m* b x))))))\n\n(defn nondet-prime? [n noAttempts]\n  (loop [num n recursLeft noAttempts]\n    (if (zero? recursLeft) true ;Probably not prime\n                           (if (= 1 (powerMod (rand-int (- n 2)) n (- n 1))) false ;Composite\n                                                                             (recur n (- recursLeft 1))))))\n\n(defn rdmOfMagnitude [order-of-magnitude]\n  (rand-int (powerMod 10 order-of-magnitude 1)))\n\n(defn algorithms-agree [n recur-attempts]\n  (= (det-prime? n) (nondet-prime? n recur-attempts)))\n\n(defn run-statistics [order-of-magnitude recur-attempts sample-size]\n  (loop [num-correct 0 total-num 0 samples (take sample-size (repeatedly #(rdmOfMagnitude order-of-magnitude)))]\n    (if (empty? samples) [num-correct total-num]\n                         (recur (+ num-correct (if (algorithms-agree (first samples) recur-attempts) 1 0)))\n                         (+ total-num 1)\n                         (rest samples))))&quot; &quot;(ns clojure_primes.stats-runner)\n\n(defn det-prime? [n]\n  (zero? (count (filter #(zero? (rem n %)) (range 3 n 2)))))\n\n(defn powerMod [b e m]\n  (defn m* [p q] (mod (* p q) m))\n  (loop [b b, e e, x 1]\n    (if (zero? e) x\n                  (if (even? e) (recur (m* b b) (/ e 2) x)\n                                (recur (m* b b) (quot e 2) (m* b x))))))\n\n(defn nondet-prime? [n noAttempts]\n  (loop [num n recursLeft noAttempts]\n    (if (zero? recursLeft) true ;Probably not prime\n                           (if (= 1 (powerMod (rand-int (- n 2)) n (- n 1))) false ;Composite\n                                                                             (recur n (- recursLeft 1))))))\n\n(defn rdmOfMagnitude [order-of-magnitude]\n  (rand-int (powerMod 10 order-of-magnitude 1)))\n\n(defn algorithms-agree [n recur-attempts]\n  (= (det-prime? n) (nondet-prime? n recur-attempts)))\n\n(defn run-statistics [order-of-magnitude recur-attempts sample-size]\n  (loop [num-correct 0 total-num 0 samples (take sample-size (repeatedly #(rdmOfMagnitude order-of-magnitude)))]\n    (if (empty? samples) [num-correct total-num]\n                         (recur (+ num-correct (if (algorithms-agree (first samples) recur-attempts) 1 0))\n                                (+ total-num 1)\n                                (rest samples)))))&quot; &quot;(algorithms-agree 1443\n                  10)&quot; &quot;(repeatedly #(rdmOfMagnitude 10                             ))&quot; &quot;(repeatedly #(rdmOfMagnitude 10))&quot; &quot;(take 5, (repeatedly #(rdmOfMagnitude 2)))&quot; &quot;(take 5 (repeat 10))&quot; &quot;(take 5 (repeatedly #(rand)))&quot; &quot;(defn rdmOfMagnitude [order-of-magnitude]\n  (rand-int (powerMod 10 order-of-magnitude 1)))\n&quot; &quot;(ns clojure_primes.stats-runner)\n\n(defn det-prime? [n]\n  (zero? (count (filter #(zero? (rem n %)) (range 3 n 2)))))\n\n(defn powerMod [b e m]\n  (defn m* [p q] (mod (* p q) m))\n  (loop [b b, e e, x 1]\n    (if (zero? e) x\n                  (if (even? e) (recur (m* b b) (/ e 2) x)\n                                (recur (m* b b) (quot e 2) (m* b x))))))\n\n(defn nondet-prime? [n noAttempts]\n  (loop [num n recursLeft noAttempts]\n    (if (zero? recursLeft) true ;Probably not prime\n                           (if (= 1 (powerMod (rand-int (- n 2)) n (- n 1))) false ;Composite\n                                                                             (recur n (- recursLeft 1))))))\n\n(defn rdmOfMagnitude [order-of-magnitude]\n  (rand-int (powerMod 10 order-of-magnitude 1)))\n\n(defn algorithms-agree [n recur-attempts]\n  (= (det-prime? n) (nondet-prime? n recur-attempts)))\n\n(defn run-statistics [order-of-magnitude recur-attempts sample-size]\n  (loop [num-correct 0 total-num 0 samples (take sample-size (repeatedly #(rdmOfMagnitude order-of-magnitude)))]\n    (if (empty? samples) [num-correct total-num]\n                         (recur\n                           (+ num-correct (if (algorithms-agree (first samples) recur-attempts) 1 0))\n                           (+ total-num 1)\n                           (rest samples)))))&quot; &quot;(rdmOfMagnitude 10)&quot; &quot;(rdmOfMagnitude 11)&quot; &quot;(ns clojure_primes.stats-runner)\n\n(defn expt [base exp]\n  (if (zero? exp) 1\n                  (expt (* base exp) (- exp 1))))\n\n(defn det-prime? [n]\n  (zero? (count (filter #(zero? (rem n %)) (range 3 n 2)))))\n\n(defn powerMod [b e m]\n  (defn m* [p q] (mod (* p q) m))\n  (loop [b b, e e, x 1]\n    (if (zero? e) x\n                  (if (even? e) (recur (m* b b) (/ e 2) x)\n                                (recur (m* b b) (quot e 2) (m* b x))))))\n\n(defn nondet-prime? [n noAttempts]\n  (loop [num n recursLeft noAttempts]\n    (if (zero? recursLeft) true ;Probably not prime\n                           (if (= 1 (powerMod (rand-int (- n 2)) n (- n 1))) false ;Composite\n                                                                             (recur n (- recursLeft 1))))))\n\n(defn rdmOfMagnitude [order-of-magnitude]\n  (rand-int (expt 10 order-of-magnitude)))\n\n(defn algorithms-agree [n recur-attempts]\n  (= (det-prime? n) (nondet-prime? n recur-attempts)))\n\n(defn run-statistics [order-of-magnitude recur-attempts sample-size]\n  (loop [num-correct 0 total-num 0 samples (take sample-size (repeatedly #(rdmOfMagnitude order-of-magnitude)))]\n    (if (empty? samples) [num-correct total-num]\n                         (recur\n                           (+ num-correct (if (algorithms-agree (first samples) recur-attempts) 1 0))\n                           (+ total-num 1)\n                           (rest samples)))))&quot; &quot;(rdmOfMagnitude 5)&quot; &quot;(ns clojure_primes.stats-runner)\n\n(defn expt [base exp]\n  (loop [base base exp exp acc 1]\n    (if (zero? exp) acc\n                    (recur base (- exp 1) (* acc base)))))\n\n(defn det-prime? [n]\n  (zero? (count (filter #(zero? (rem n %)) (range 3 n 2)))))\n\n(defn powerMod [b e m]\n  (defn m* [p q] (mod (* p q) m))\n  (loop [b b, e e, x 1]\n    (if (zero? e) x\n                  (if (even? e) (recur (m* b b) (/ e 2) x)\n                                (recur (m* b b) (quot e 2) (m* b x))))))\n\n(defn nondet-prime? [n noAttempts]\n  (loop [num n recursLeft noAttempts]\n    (if (zero? recursLeft) true ;Probably not prime\n                           (if (= 1 (powerMod (rand-int (- n 2)) n (- n 1))) false ;Composite\n                                                                             (recur n (- recursLeft 1))))))\n\n(defn rdmOfMagnitude [order-of-magnitude]\n  (rand-int (expt 10 order-of-magnitude)))\n\n(defn algorithms-agree [n recur-attempts]\n  (= (det-prime? n) (nondet-prime? n recur-attempts)))\n\n(defn run-statistics [order-of-magnitude recur-attempts sample-size]\n  (loop [num-correct 0 total-num 0 samples (take sample-size (repeatedly #(rdmOfMagnitude order-of-magnitude)))]\n    (if (empty? samples) [num-correct total-num]\n                         (recur\n                           (+ num-correct (if (algorithms-agree (first samples) recur-attempts) 1 0))\n                           (+ total-num 1)\n                           (rest samples)))))&quot; &quot;(expt 10 5)&quot; &quot;(run-statistics 2 10 10)&quot; &quot;(expt 10 2)&quot; &quot;(rdmOfMagnitude 2)&quot; &quot;(take 10 (repeatedly #(rdmOfMagnitude 2)))&quot; &quot;(det-prime? 5)&quot; &quot;(powerMod (rand-int 3) 5 (4))&quot; &quot;(powerMod (rand-int 3) 5 4)&quot; &quot;(ns clojure_primes.stats-runner)\n\n(defn expt [base exp]\n  (loop [base base exp exp acc 1]\n    (if (zero? exp) acc\n                    (recur base (- exp 1) (* acc base)))))\n\n(defn det-prime? [n]\n  (zero? (count (filter #(zero? (rem n %)) (range 3 n 2)))))\n\n(defn powerMod [b e m]\n  (defn m* [p q] (mod (* p q) m))\n  (loop [b b, e e, x 1]\n    (if (zero? e) x\n                  (if (even? e) (recur (m* b b) (/ e 2) x)\n                                (recur (m* b b) (quot e 2) (m* b x))))))\n\n(defn nondet-prime? [n noAttempts]\n  (loop [num n recursLeft noAttempts]\n    (if (zero? recursLeft) (if (= 1 (powerMod (rand-int (- n 2)) n (- n 1))) false ;Composite\n                                                                             (recur n (- recursLeft 1))))))\ntrue ;Probably not prime\n\n\n(defn rdmOfMagnitude [order-of-magnitude]\n  (rand-int (expt 10 order-of-magnitude)))\n\n(defn algorithms-agree [n recur-attempts]\n  (= (det-prime? n) (nondet-prime? n recur-attempts)))\n\n(defn run-statistics [order-of-magnitude recur-attempts sample-size]\n  (loop [num-correct 0 total-num 0 samples (take sample-size (repeatedly #(rdmOfMagnitude order-of-magnitude)))]\n    (if (empty? samples) [num-correct total-num]\n                         (recur\n                           (+ num-correct (if (algorithms-agree (first samples) recur-attempts) 1 0))\n                           (+ total-num 1)\n                           (rest samples)))))&quot; &quot;(nondet-prime? 10)&quot; &quot;(ns clojure_primes.stats-runner)\n\n(defn expt [base exp]\n  (loop [base base exp exp acc 1]\n    (if (zero? exp) acc\n                    (recur base (- exp 1) (* acc base)))))\n\n(defn det-prime? [n]\n  (zero? (count (filter #(zero? (rem n %)) (range 3 n 2)))))\n\n(defn powerMod [b e m]\n  (defn m* [p q] (mod (* p q) m))\n  (loop [b b, e e, x 1]\n    (if (zero? e) x\n                  (if (even? e) (recur (m* b b) (/ e 2) x)\n                                (recur (m* b b) (quot e 2) (m* b x))))))\n\n(defn nondet-prime? [n noAttempts]\n  (loop [num n recursLeft noAttempts]\n    (if (zero? recursLeft) true ;Probably not prime \n                           (if (= 1 (powerMod (rand-int (- n 2)) n (- n 1))) (recur n (- recursLeft 1))))))\nfalse ;Composite\n\n\n\n(defn rdmOfMagnitude [order-of-magnitude]\n  (rand-int (expt 10 order-of-magnitude)))\n\n(defn algorithms-agree [n recur-attempts]\n  (= (det-prime? n) (nondet-prime? n recur-attempts)))\n\n(defn run-statistics [order-of-magnitude recur-attempts sample-size]\n  (loop [num-correct 0 total-num 0 samples (take sample-size (repeatedly #(rdmOfMagnitude order-of-magnitude)))]\n    (if (empty? samples) [num-correct total-num]\n                         (recur\n                           (+ num-correct (if (algorithms-agree (first samples) recur-attempts) 1 0))\n                           (+ total-num 1)\n                           (rest samples)))))&quot; &quot;(defn nondet-prime? [n noAttempts]\n  (loop [num n recursLeft noAttempts]\n    (if (zero? recursLeft) true ;Probably not prime\n                           (if (= 1 (powerMod (rand-int (- n 2)) n (- n 1))) (recur n (- recursLeft 1))))))\nfalse ;Composite&quot; &quot;(ns clojure_primes.stats-runner)\n\n(defn expt [base exp]\n  (loop [base base exp exp acc 1]\n    (if (zero? exp) acc\n                    (recur base (- exp 1) (* acc base)))))\n\n(defn det-prime? [n]\n  (zero? (count (filter #(zero? (rem n %)) (range 3 n 2)))))\n\n(defn powerMod [b e m]\n  (defn m* [p q] (mod (* p q) m))\n  (loop [b b, e e, x 1]\n    (if (zero? e) x\n                  (if (even? e) (recur (m* b b) (/ e 2) x)\n                                (recur (m* b b) (quot e 2) (m* b x))))))\n\n(defn nondet-prime? [n noAttempts]\n  (loop [num n recursLeft noAttempts]\n    (if (zero? recursLeft) true ;Probably not prime\n                           (if (= 1 (powerMod (rand-int (- n 2)) n (- n 1))) (recur n (- recursLeft 1))\n                                                                             false )))) ;Composite\n\n(defn rdmOfMagnitude [order-of-magnitude]\n  (rand-int (expt 10 order-of-magnitude)))\n\n(defn algorithms-agree [n recur-attempts]\n  (= (det-prime? n) (nondet-prime? n recur-attempts)))\n\n(defn run-statistics [order-of-magnitude recur-attempts sample-size]\n  (loop [num-correct 0 total-num 0 samples (take sample-size (repeatedly #(rdmOfMagnitude order-of-magnitude)))]\n    (if (empty? samples) [num-correct total-num]\n                         (recur\n                           (+ num-correct (if (algorithms-agree (first samples) recur-attempts) 1 0))\n                           (+ total-num 1)\n                           (rest samples)))))&quot; &quot;(algorithms-agree 1 10) &quot; &quot;(algorithms-agree 2 10) &quot; &quot;(algorithms-agree 3 10) &quot; &quot;(ns clojure_primes.stats-runner)\n\n(defn expt [base exp]\n  (loop [base base exp exp acc 1]\n    (if (zero? exp) acc\n                    (recur base (- exp 1) (* acc base)))))\n\n(defn det-prime? [n]\n  (zero? (count (filter #(zero? (rem n %)) (range 3 n 2)))))\n\n(defn powerMod [b e m]\n  (defn m* [p q] (mod (* p q) m))\n  (loop [b b, e e, x 1]\n    (if (zero? e) x\n                  (if (even? e) (recur (m* b b) (/ e 2) x)\n                                (recur (m* b b) (quot e 2) (m* b x))))))\n\n(defn nondet-prime? [n noAttempts]\n  (loop [num n recursLeft noAttempts]\n    (if (zero? recursLeft) true ;Probably not prime\n                           (if (= 1 (powerMod (rand-int (- n 2)) n (- n 1))) (recur n (- recursLeft 1))\n                                                                             false )))) ;Composite\n\n(defn rdmOfMagnitude [order-of-magnitude]\n  (+ (rand-int (expt 10 order-of-magnitude)) 2))\n\n(defn algorithms-agree [n recur-attempts]\n  (= (det-prime? n) (nondet-prime? n recur-attempts)))\n\n(defn run-statistics [order-of-magnitude recur-attempts sample-size]\n  (loop [num-correct 0 total-num 0 samples (take sample-size (repeatedly #(rdmOfMagnitude order-of-magnitude)))]\n    (if (empty? samples) [num-correct total-num]\n                         (recur\n                           (+ num-correct (if (algorithms-agree (first samples) recur-attempts) 1 0))\n                           (+ total-num 1)\n                           (rest samples)))))&quot; &quot;(algorithms-agree 1 10)&quot; &quot;(algorithms-agree 2 10)&quot; &quot;(det-prime? 2)&quot; &quot;(nondet-prime? 2 10)&quot; &quot;(ns clojure_primes.stats-runner)\n\n(defn expt [base exp]\n  (loop [base base exp exp acc 1]\n    (if (zero? exp) acc\n                    (recur base (- exp 1) (* acc base)))))\n\n(defn det-prime? [n]\n  (zero? (count (filter #(zero? (rem n %)) (range 3 n 2)))))\n\n(defn powerMod [b e m]\n  (defn m* [p q] (mod (* p q) m))\n  (loop [b b, e e, x 1]\n    (if (zero? e) x\n                  (if (even? e) (recur (m* b b) (/ e 2) x)\n                                (recur (m* b b) (quot e 2) (m* b x))))))\n\n(defn nondet-prime? [n noAttempts]\n  (loop [num n recursLeft noAttempts]\n    (if (zero? recursLeft) true ;Probably not prime\n                           (if (= 1 (powerMod (rand-int (- n 2)) n (- n 1))) (recur n (- recursLeft 1))\n                                                                             false )))) ;Composite\n\n(defn rdmOfMagnitude [order-of-magnitude]\n  (+ (rand-int (expt 10 order-of-magnitude)) 4))\n\n(defn algorithms-agree [n recur-attempts]\n  (= (det-prime? n) (nondet-prime? n recur-attempts)))\n\n(defn run-statistics [order-of-magnitude recur-attempts sample-size]\n  (loop [num-correct 0 total-num 0 samples (take sample-size (repeatedly #(rdmOfMagnitude order-of-magnitude)))]\n    (if (empty? samples) [num-correct total-num]\n                         (recur\n                           (+ num-correct (if (algorithms-agree (first samples) recur-attempts) 1 0))\n                           (+ total-num 1)\n                           (rest samples)))))&quot; &quot;(ns clojure_primes.stats-runner)\n\n(defn expt [base exp]\n  (loop [base base exp exp acc 1]\n    (if (zero? exp) acc\n                    (recur base (- exp 1) (* acc base)))))\n\n(defn det-prime? [n]\n  (zero? (count (filter #(zero? (rem n %)) (range 3 n 2)))))\n\n(defn powerMod [b e m]\n  (defn m* [p q] (mod (* p q) m))\n  (loop [b b, e e, x 1]\n    (if (zero? e) x\n                  (if (even? e) (recur (m* b b) (/ e 2) x)\n                                (recur (m* b b) (quot e 2) (m* b x))))))\n\n(defn is-witness-for? [w, p]\n  (= 1 (powerMod w p (- p 1))))\n\n(defn nondet-prime? [n noAttempts]\n  (loop [num n recursLeft noAttempts]\n    (if (zero? recursLeft) true ;Probably not prime\n                           (if (is-witness-for? (+ 1 (rand-int (- n 2))) n) false\n                                                                            (recur n (- noAttempts 1)) )))) ;Composite\n\n(defn rdmOfMagnitude [order-of-magnitude]\n  (+ (rand-int (expt 10 order-of-magnitude)) 4))\n\n(defn algorithms-agree [n recur-attempts]\n  (= (det-prime? n) (nondet-prime? n recur-attempts)))\n\n(defn run-statistics [order-of-magnitude recur-attempts sample-size]\n  (loop [num-correct 0 total-num 0 samples (take sample-size (repeatedly #(rdmOfMagnitude order-of-magnitude)))]\n    (if (empty? samples) [num-correct total-num]\n                         (recur\n                           (+ num-correct (if (algorithms-agree (first samples) recur-attempts) 1 0))\n                           (+ total-num 1)\n                           (rest samples)))))&quot; &quot;(run-statistics 1 10 10)&quot; &quot;(algorithms-agree 5 10)&quot; &quot;(is-witness-for? 5\n                 5)&quot; &quot;(+ 1 (rand-int 2))&quot; &quot;(+ 1 (rand-int 3))&quot; &quot;(+ 1 (rand-int 4))&quot; &quot;(ns clojure_primes.stats-runner)\n\n(defn expt [base exp]\n  (loop [base base exp exp acc 1]\n    (if (zero? exp) acc\n                    (recur base (- exp 1) (* acc base)))))\n\n(defn det-prime? [n]\n  (zero? (count (filter #(zero? (rem n %)) (range 3 n 2)))))\n\n(defn powerMod [b e m]\n  (defn m* [p q] (mod (* p q) m))\n  (loop [b b, e e, x 1]\n    (if (zero? e) x\n                  (if (even? e) (recur (m* b b) (/ e 2) x)\n                                (recur (m* b b) (quot e 2) (m* b x))))))\n\n(defn is-witness-for? [w, p]\n  (= 1 (powerMod w p (- p 1))))\n\n(defn nondet-prime? [n noAttempts]\n  (loop [num n recursLeft noAttempts]\n    (if (zero? recursLeft) true ;Probably not prime\n                           (if (is-witness-for? (+ 1 (rand-int (- n 1))) n) false ;Composite\n                                                                            (recur n (- noAttempts 1)) ))))\n\n(defn rdmOfMagnitude [order-of-magnitude]\n  (+ (rand-int (expt 10 order-of-magnitude)) 4))\n\n(defn algorithms-agree [n recur-attempts]\n  (= (det-prime? n) (nondet-prime? n recur-attempts)))\n\n(defn run-statistics [order-of-magnitude recur-attempts sample-size]\n  (loop [num-correct 0 total-num 0 samples (take sample-size (repeatedly #(rdmOfMagnitude order-of-magnitude)))]\n    (if (empty? samples) [num-correct total-num]\n                         (recur\n                           (+ num-correct (if (algorithms-agree (first samples) recur-attempts) 1 0))\n                           (+ total-num 1)\n                           (rest samples)))))&quot; &quot;(ns clojure_primes.stats-runner)\n\n(defn expt [base exp]\n  (loop [base base exp exp acc 1]\n    (if (zero? exp) acc\n                    (recur base (- exp 1) (* acc base)))))\n\n(defn det-prime? [n]\n  (zero? (count (filter #(zero? (rem n %)) (range 3 n 2)))))\n\n(defn powerMod [b e m]\n  (defn m* [p q] (mod (* p q) m))\n  (loop [b b, e e, x 1]\n    (if (zero? e) x\n                  (if (even? e) (recur (m* b b) (/ e 2) x)\n                                (recur (m* b b) (quot e 2) (m* b x))))))\n\n(defn is-witness-for? [w, p]\n  (= 1 (powerMod w p (- p 1))))\n\n(defn nondet-prime? [n noAttempts]\n  (loop [num n recursLeft noAttempts]\n    (if (zero? recursLeft) true ; Probably not prime\n                           (if (is-witness-for? (+ 1 (rand-int (- n 1))) n) (recur n (- noAttempts 1))\n                                                                            false ;Composite\n                                                                            ))))\n\n(defn rdmOfMagnitude [order-of-magnitude]\n  (+ (rand-int (expt 10 order-of-magnitude)) 4))\n\n(defn algorithms-agree [n recur-attempts]\n  (= (det-prime? n) (nondet-prime? n recur-attempts)))\n\n(defn run-statistics [order-of-magnitude recur-attempts sample-size]\n  (loop [num-correct 0 total-num 0 samples (take sample-size (repeatedly #(rdmOfMagnitude order-of-magnitude)))]\n    (if (empty? samples) [num-correct total-num]\n                         (recur\n                           (+ num-correct (if (algorithms-agree (first samples) recur-attempts) 1 0))\n                           (+ total-num 1)\n                           (rest samples)))))&quot; &quot;(ns clojure_primes.stats-runner)\n\n(defn expt [base exp]\n  (loop [base base exp exp acc 1]\n    (if (zero? exp) acc\n                    (recur base (- exp 1) (* acc base)))))\n\n(defn det-prime? [n]\n  (zero? (count (filter #(zero? (rem n %)) (range 3 n 2)))))\n\n(defn powerMod [b e m]\n  (defn m* [p q] (mod (* p q) m))\n  (loop [b b, e e, x 1]\n    (if (zero? e) x\n                  (if (even? e) (recur (m* b b) (/ e 2) x)\n                                (recur (m* b b) (quot e 2) (m* b x))))))\n\n(defn is-witness-for? [w, p]\n  (= 1 (powerMod w (- p 1) p)))\n\n(defn nondet-prime? [n noAttempts]\n  (loop [num n recursLeft noAttempts]\n    (if (zero? recursLeft) true ; Probably not prime\n                           (if (is-witness-for? (+ 1 (rand-int (- n 1))) n) (recur n (- noAttempts 1))\n                                                                            false ;Composite\n                                                                            ))))\n\n(defn rdmOfMagnitude [order-of-magnitude]\n  (+ (rand-int (expt 10 order-of-magnitude)) 4))\n\n(defn algorithms-agree [n recur-attempts]\n  (= (det-prime? n) (nondet-prime? n recur-attempts)))\n\n(defn run-statistics [order-of-magnitude recur-attempts sample-size]\n  (loop [num-correct 0 total-num 0 samples (take sample-size (repeatedly #(rdmOfMagnitude order-of-magnitude)))]\n    (if (empty? samples) [num-correct total-num]\n                         (recur\n                           (+ num-correct (if (algorithms-agree (first samples) recur-attempts) 1 0))\n                           (+ total-num 1)\n                           (rest samples)))))&quot; &quot;(nondet-prime? 5)&quot; &quot;(nondet-prime? 5 10)&quot; &quot;(defn powerMod [b e m]\n  (defn m* [p q] (mod (* p q) m))\n  (loop [b b, e e, x 1]\n    (if (zero? e) x\n                  (if (even? e) (recur (m* b b) (/ e 2) x)\n                                (recur (m* b b) (quot e 2) (m* b x))))))\n\n(defn is-witness-for? [w, p]\n  (= 1 (powerMod w (- p 1) p)))\n&quot; &quot;(is-witness-for? 1 5)&quot; &quot;(is-witness-for? 2 5)&quot; &quot;(is-witness-for? 3 5)&quot; &quot;(is-witness-for? 4 5)&quot; &quot;(is-witness-for? 3 4)&quot; &quot;(is-witness-for? 3 8)&quot; &quot;(is-witness-for? 3 11)&quot; &quot;(is-witness-for? 8\n                 11)&quot; &quot;(defn nondet-prime? [n noAttempts]\n  (loop [num n recursLeft noAttempts]\n    (if (zero? recursLeft) true ; Probably not prime\n                           (if (is-witness-for? (+ 1 (rand-int (- n 1))) n) (recur n (- noAttempts 1))\n                                                                            false ;Composite\n                                                                            ))))&quot; &quot;(nondet-prime? 5 1)&quot; &quot;(nondet-prime? 5 2)&quot;], :remote []}}</component>
</project>

